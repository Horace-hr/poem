package model;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import model.base.BaseChapter;
import utils.DicUtil;
import utils.WebContextUtil;

import com.alibaba.fastjson.JSONObject;
import com.jfinal.core.Controller;
import com.jfinal.kit.StrKit;
import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.Page;
import com.jfinal.plugin.activerecord.Record;
import com.jfinal.plugin.ehcache.CacheKit;
import com.jfinal.weixin.sdk.api.TemplateData;
import com.jfinal.weixin.sdk.api.TemplateMsgApi;

/**
 * Generated by JFinal.
 */
@SuppressWarnings("serial")
public class Chapter extends BaseChapter<Chapter> {
	public static final Chapter dao = new Chapter().dao();
	
	/*********************缓存存储*************************/
	//【缓存】查询小说章节信息By - id 
	public Chapter findByIdInCache(String id) {
		return this.findFirstByCache(DicUtil.CACHE_CHAPTER, id, "SELECT tc.* , tn.nName FROM t_chapter tc LEFT JOIN t_novel tn ON tn.id = tc.novelId WHERE tc.id = ? " , id );
	}
	
	//【缓存】查询小说章节分页:更新、保存小说、章节信息时清理 - 仅限用于小说章节详情内容查询时使用
	public Page<Record> getJsonPageInCache(Integer pageNum , String novelId ) {
		List<String> whereParams = new ArrayList<String>();
		String select = "SELECT tc.*, tn.nName " ;
		StringBuffer sBuffer = new StringBuffer(" FROM t_chapter tc ");
		sBuffer.append(" LEFT JOIN t_novel tn ON tc.novelId = tn.id "); 
		sBuffer.append(" WHERE 1=1 ");
		this.addEqualCondition(sBuffer, whereParams ,"tc.novelId", novelId ) ;
		sBuffer.append(" ORDER BY tc.number ");
		return Db.paginateByCache(DicUtil.CACHE_CHAPTER_NOVEL, pageNum + novelId , pageNum, 1 , select, sBuffer.toString(), whereParams.toArray() ) ;
	}
	
	//【缓存】用户查询小说章节列表信息、小说基础信息
	public Page<Record> getJsonPageInCache(Integer pageNum , String novelId , int pageSize , int orderType) {
		List<String> whereParams = new ArrayList<String>();
		String select = "SELECT tc.title , tc.id , tc.number , tc.time , tc.price , tc.count , tc.novelId " ;
		StringBuffer sBuffer = new StringBuffer(" FROM t_chapter tc ");
		sBuffer.append(" WHERE 1=1 ");
		this.addEqualCondition(sBuffer, whereParams ,"tc.novelId", novelId ) ;
		sBuffer.append(" ORDER BY tc.number ");
		if (orderType == 1) {
			sBuffer.append(" DESC ");
		}
		return Db.paginateByCache(DicUtil.CACHE_CHAPTER_NOVEL, novelId + pageNum + pageSize + orderType , pageNum, pageSize , select, sBuffer.toString(), whereParams.toArray() ) ;
	}
	
	//根据小说章节标题查询
	public Page<Record> getJsonPageInCache(Integer pageNum , String novelId , int pageSize , String title) {
		List<String> whereParams = new ArrayList<String>();
		String select = "SELECT tc.title , tc.number , tc.novelId " ;
		StringBuffer sBuffer = new StringBuffer(" FROM t_chapter tc ");
		sBuffer.append(" WHERE 1=1 ");
		this.addEqualCondition(sBuffer,  whereParams ,"tc.novelId", novelId ) ;
		this.addLikeCondition(sBuffer,  whereParams ,"tc.title", title) ;
		sBuffer.append(" ORDER BY tc.number ");
		return Db.paginateByCache(DicUtil.CACHE_CHAPTER_NOVEL,  pageNum + pageSize + title + novelId , pageNum, pageSize , select, sBuffer.toString(), whereParams.toArray() ) ;
	}
	
	/*********************缓存清理*************************/
	public JSONObject save(Chapter chapter) {
		String id = chapter.getId() ;
		Date date = new Date() ;
		chapter.setTime(date);
		Novel novel = Novel.dao.findByIdInCache(chapter.getNovelId());
		//该章节是否免费
		boolean isFree = novel.getFreeNum() >= chapter.getNumber() ? true : false ;
		if (isFree) {
			chapter.setPrice(0);
		}else{
			Config config = Config.dao.findByKey(Config.KEY_PRICE);
			chapter.setPrice(Math.round( ( (chapter.getCount()*config.getValue())/1000 ) ));
		}
		if (StrKit.isBlank(id)) {
			if (novel.getIsEnd()) {
				return sendErrorJson("该小说已完本，无法再次新增章节");
			}
			id = getIds() ;
			chapter.setId(id);
			chapter.save() ;
			//更新小说的基本信息
			novel.setUpdateTime(date);
			novel.setLChapterId(id);
			novel.setLChapterNum(chapter.getNumber());
			novel.setLChapterTitle(chapter.getTitle());
			if (chapter.getNumber() == 1) {
				novel.setFChapterId(id);
			}
			novel.setCount(novel.getCount() + chapter.getCount());
		}else{
			novel.setCount(novel.getCount() + chapter.getCount() - this.findByIdInCache(id).getCount());
			
			chapter.update();
			//清理缓存:查询章节信息
			CacheKit.remove(DicUtil.CACHE_CHAPTER, id);
		}
		//更新小说信息
		novel.update();
		Novel.dao.clearCache(novel.getId());
		//清理缓存：查询小说章节分页信息
		CacheKit.removeAll(DicUtil.CACHE_CHAPTER_NOVEL);
		return sendSuccessJson() ;
	}
	
	public JSONObject delete(String id) {
		Chapter chapter = this.findByIdInCache(id);
		//清理缓存：查询小说总章节数量
		CacheKit.remove(DicUtil.CACHE_CHAPTER, id);
		int delNumber = chapter.getNumber() ;
		this.deleteById(id);
		//重置小说的章节排序
		int lastNum = Chapter.dao.resetNumber(chapter.getNovelId() , delNumber);
		//更新小说的第一章、最后一章信息
		Novel.dao.resetStartAndEnd(chapter.getNovelId() , lastNum) ;
		//清理缓存：查询小说章节分页信息
		CacheKit.removeAll(DicUtil.CACHE_CHAPTER_NOVEL);
		return sendSuccessJson() ;
	}
	
	//重置该小说章节的所有章节排序 - 返回当前小说章节总数
	public int resetNumber(String novelId , int delNumber) {
		String sql ="UPDATE t_chapter SET number = number -1 WHERE novelId = ? AND number > ? ORDER BY number " ;
		int num = Db.update(sql , novelId , delNumber) ;
		//章节分页缓存
		CacheKit.remove(DicUtil.CACHE_CHAPTER_NOVEL, novelId);
		return delNumber + num - 1 ;
	}
	
	public void deleteByNovelId(String novelId) {
		String sql = "DELETE FROM t_chapter WHERE novelId = ? " ;
		int count = Db.update(sql, novelId);
		System.out.println(count);
	}
	
	/*********************普通业务*************************/
	//新增渠道时，用于根据小说标题搜索小说信息
	public Page<Record> getPageInCache(String title) {
		List<String> whereParams = new ArrayList<String>();
		String select = "SELECT tc.number , tc.novelId, tc.title , tn.nName " ;
		StringBuffer sBuffer = new StringBuffer(" FROM t_chapter tc ");
		sBuffer.append(" LEFT JOIN t_novel tn ON tc.novelId = tn.id "); 
		sBuffer.append(" WHERE 1=1 ");
		this.addLikeCondition(sBuffer, whereParams , "tc.title", title);
		sBuffer.append(" ORDER BY tc.number ");
		return Db.paginate(1, 10, select, sBuffer.toString() , whereParams.toArray()) ;
	}
		
	//查询分页 -- 仅限后台查询章节列表使用
	public Page<Record> getPage(Integer pageNum , Map<String, String> map) {
		List<String> whereParams = new ArrayList<String>();
		String select = "SELECT tc.number ,tc.title , tc.time , tc.price , tc.income , tc.count,tc.id,tc.novelId , tn.nName " ;
		StringBuffer sBuffer = new StringBuffer(" FROM t_chapter tc ");
		sBuffer.append(" LEFT JOIN t_novel tn ON tc.novelId = tn.id "); 
		sBuffer.append(" WHERE 1=1 ");
		this.addEqualCondition(sBuffer, whereParams , "tn.id", map.get("novelId"));
		this.addLikeCondition(sBuffer,  whereParams ,"tn.nName", map.get("nName"));
		sBuffer.append(" ORDER BY tn.id DESC , tc.number DESC ");
		return Db.paginate(pageNum, DicUtil.PAGE_SIZE, select, sBuffer.toString() , whereParams.toArray() ) ;
	}
	
	//查询章节内容用户是否需要付费
	public boolean needPay(Page<Record> page , String userId) {
		if (page.getList().size() == 0) {
			return false ;
		}
		if (StrKit.isBlank(userId)) {
			return true ;
		}
		Record record = page.getList().get(0) ;
		int price = record.getInt("price");
		if (price > 0) {
			//查询购买记录
			BuyRecord buyRecord = BuyRecord.dao.findRecordInCache(userId , record.getStr("id"));
			if (null == buyRecord) {
				return true ;
			}
		}
		return false ;
	}
	
	//查询开始章节和最后章节信息 - 仅限重置小说章节信息时使用
	public List<Chapter> findStartAndEnd(String novelId , int lastNum) {
		return this.find(" SELECT tc.id , tc.title , tc.number FROM t_chapter tc WHERE tc.novelId = ? AND ( tc.number = 1 OR tc.number = ?) ORDER BY tc.number " , novelId , lastNum);
	}
	
	//处理字数
	public String changeCount(int count) {
		String counts = "" + count ;
		if (count < 99999) {
			return counts ;
		}else{
			return counts.substring(0,counts.length() - 4) + "万" ;
		}
	}
	
	public JSONObject pushMsg(String chapterId , Controller con) {
		Chapter chapter = this.findByIdInCache(chapterId) ;
		if (null == chapter) {
			return sendErrorJson() ;
		}
		
		//查询所有关注用户
		String novelId = chapter.getNovelId() ;
		int chapterNum = chapter.getNumber() ;
		List<History> userHistories = History.dao.findfollowers(novelId , chapterNum ) ;
		Novel novel = Novel.dao.findByIdInCache(novelId) ;
		
		//通知所有关注用户
		String userId = "" ;
		String title = "《" + novel.getNName() + "》 今日更新" ;
		String remark = "感谢您的关注，您可以在个人中心 > 关注提醒 中选择关闭该提醒~" ;
		String url = WebContextUtil.getContextPath(con.getRequest())  + "/novel?page=chapterInfo&params=" + chapterNum +  "-" + novelId ;
		for (History history : userHistories) {
			userId = history.getUserId() ;
			TemplateMsgApi.send(
					TemplateData.New()
					// 消息接收者
				    .setTouser(userId)
				    // 模板id
				    .setTemplate_id("gGgdd5nyLYoNGNJy2r_xOo4COtn4k6DjRmR0z0HcJb8")
				    .setTopcolor("#eb414a")
				    .setUrl( url )

				    // 模板参数
				    .add("first", title , "#428bca")
				    //.add("keyword1", blog.getTitle() , "#999")
				    //.add("keyword2", new SimpleDateFormat("yyyy年MM月dd日 HH:mm").format(blog.getTime())  , "#999")
				    //.add("keyword3",  author.getNickname() , "#999")
				    .add("keyword4",  "已通过审核" , "#999")
				    .add("remark", remark , "#999")
				    .build()
				);	
		}
		
		return sendSuccessJson("消息推送成功，共有" + userHistories + "位用户接收到了消息") ;
	}
	
	//查询最后一章
	public Chapter getLastChapter(String novelId) {
		String sqlString = "SELECT tc.id , tc.number , tc.title FROM t_chapter tc WHERE tc.novelId = ? ORDER BY tc.number DESC " ;
		return Chapter.dao.findFirst(sqlString , novelId) ;
	}
	
}
